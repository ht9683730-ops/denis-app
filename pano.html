<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–ü–∞–Ω–æ—Ä–∞–º–∞</title>

<style>
body { margin: 0; overflow: hidden; background:#000; }
canvas { display: block; }

.info-box {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.85);
    color: #fff;
    padding: 16px;
    border-radius: 10px;
    max-width: 380px;
    width: calc(100% - 40px);
    z-index: 10;
    display: none;
}

.info-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

#infoText {
    margin-top: 10px;
    font-size: 18px;
    line-height: 1.5;
}

.btn {
    height: 40px;
    padding: 0 16px;
    font-size: 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background: rgba(255,255,255,0.2);
    color: white;
}

.btn:hover {
    background: rgba(255,255,255,0.3);
}

.tour-nav {
    position: fixed;
    top: 50%;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
    pointer-events: none;
    transform: translateY(-50%);
}

.tour-nav button {
    pointer-events: all;
    font-size: 26px;
    width: 150px;
    height: 150px;
    border-radius: 50%;
    background: rgba(0,0,0,0.7);
    color: white;
    border: 2px solid white;
    cursor: pointer;
}

.tour-nav button:hover {
    background: rgba(0,0,0,0.9);
}

.tour-nav button:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.top-buttons {
    position: fixed;
    top: 20px;
    left: 20px;
    right: 20px;
    z-index: 20;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.top-btn {
    background: rgba(0,0,0,0.7);
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 12px 20px;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s;
}

.top-btn:hover {
    background: rgba(0,0,0,0.9);
}

.top-btn.active {
    background: rgba(76, 175, 80, 0.8);
}

.top-btn.return {
    background: rgba(255, 152, 0, 0.8);
}

.progress-bar {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    z-index: 20;
    display: none;
}

.progress-fill {
    background: #4CAF50;
    height: 6px;
    border-radius: 3px;
    margin-top: 5px;
    transition: width 0.3s;
}

.loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 24px;
    z-index: 100;
}
</style>
</head>
<body>
<div class="loading" id="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>

<div class="top-buttons">
    <button class="top-btn" onclick="goToMap()">üó∫Ô∏è –ö–∞—Ä—Ç–∞</button>
    <button class="top-btn" id="freeModeBtn" onclick="toggleFreeMode()" style="display:none;">üîì –°–≤–æ–±–æ–¥–Ω—ã–π —Ä–µ–∂–∏–º</button>
    <button class="top-btn return" id="returnBtn" onclick="returnToRoute()" style="display:none;">‚Ü©Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –º–∞—Ä—à—Ä—É—Ç</button>
</div>

<div class="progress-bar" id="progressBar">
    <div id="progressText">–¢–æ—á–∫–∞ 1 –∏–∑ 10</div>
    <div style="width:200px; background:rgba(255,255,255,0.2); border-radius:3px;">
        <div class="progress-fill" id="progressFill" style="width:10%;"></div>
    </div>
</div>

<div class="info-box" id="infoBox">
    <div class="info-header">
        <h3 id="infoTitle"></h3>
        <div style="display:flex; gap:5px;">
            <button class="btn" onclick="changeTextSize(-2)">A-</button>
            <button class="btn" onclick="changeTextSize(2)">A+</button>
            <button class="btn" onclick="closeInfo()">‚úï</button>
        </div>
    </div>
    <div id="infoText"></div>
</div>

<div class="tour-nav" id="tourNav" style="display:none">
    <button id="prevBtn" onclick="prev()">‚¨Ö</button>
    <button id="nextBtn" onclick="next()">‚û°</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="map-data.js"></script>
<script src="pano-data.js"></script>
<script src="tour-data.js"></script>

<script>
let activeLocations = [];
let activeHotspots = {};
let db = null;
let scene, camera, renderer;
let lon, lat;
let freeMode = false;
let step = 0;
let tourPath = [];
let originalTourPath = [];
let panoId;
let mode;

function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('TourDatabase', 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
            db = request.result;
            resolve(db);
        };
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('images')) {
                db.createObjectStore('images');
            }
        };
    });
}

function loadImage(key) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(['images'], 'readonly');
        const store = transaction.objectStore('images');
        const request = store.get(key);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

async function loadStoredData() {
    await initDB();
    const stored = localStorage.getItem('tourData');
    if (stored) {
        try {
            const data = JSON.parse(stored);
            activeLocations = data.locations || locations;
            activeHotspots = data.hotspots || panoHotSpots;
        } catch (e) {
            activeLocations = locations;
            activeHotspots = panoHotSpots;
        }
    } else {
        activeLocations = locations;
        activeHotspots = panoHotSpots;
    }
}

function goToMap() {
    location.href = "index.html";
}

function toggleFreeMode() {
    freeMode = !freeMode;
    const btn = document.getElementById("freeModeBtn");
    const returnBtn = document.getElementById("returnBtn");
    
    if (freeMode) {
        btn.classList.add("active");
        btn.textContent = "üîì –°–≤–æ–±–æ–¥–Ω—ã–π —Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–µ–Ω";
        returnBtn.style.display = "block";
        createHotspots();
    } else {
        btn.classList.remove("active");
        btn.textContent = "üîì –°–≤–æ–±–æ–¥–Ω—ã–π —Ä–µ–∂–∏–º";
        returnBtn.style.display = "none";
        createHotspots();
    }
}

function next() {
    if (step < tourPath.length - 1) {
        location.href = `pano.html?mode=tour&start=${originalTourPath[0]}&end=${originalTourPath[originalTourPath.length-1]}&step=${step+1}`;
    }
}

function prev() {
    if (step > 0) {
        location.href = `pano.html?mode=tour&start=${originalTourPath[0]}&end=${originalTourPath[originalTourPath.length-1]}&step=${step-1}`;
    }
}

function returnToRoute() {
    const remainingPath = originalTourPath.slice(step);
    if (remainingPath.includes(panoId)) {
        alert("–í—ã —É–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –Ω–∞ –º–∞—Ä—à—Ä—É—Ç–µ!");
        return;
    }
    
    let minDist = Infinity;
    let nearestStep = step;
    const currentLoc = activeLocations.find(l => l.id === panoId);
    
    remainingPath.forEach((id, idx) => {
        const targetLoc = activeLocations.find(l => l.id === id);
        const dist = Math.sqrt(
            Math.pow(currentLoc.lat - targetLoc.lat, 2) +
            Math.pow(currentLoc.lng - targetLoc.lng, 2)
        );
        if (dist < minDist) {
            minDist = dist;
            nearestStep = step + idx;
        }
    });
    
    location.href = `pano.html?mode=tour&start=${originalTourPath[0]}&end=${originalTourPath[originalTourPath.length-1]}&step=${nearestStep}`;
}

function showInfo(d) {
    const infoBox = document.getElementById("infoBox");
    const infoText = document.getElementById("infoText");
    infoText.style.fontSize = "18px";
    document.getElementById("infoTitle").textContent = d.title ?? "";
    infoText.innerHTML = d.text ?? "";
    infoBox.style.display = "block";
}

function closeInfo() {
    document.getElementById("infoBox").style.display = "none";
}

function changeTextSize(delta) {
    const infoText = document.getElementById("infoText");
    let currentSize = parseInt(infoText.style.fontSize) || 18;
    currentSize += delta;
    infoText.style.fontSize = currentSize + "px";
}

function updateProgress() {
    const total = originalTourPath.length;
    const current = step + 1;
    const percent = (current / total) * 100;
    
    document.getElementById("progressText").textContent = `–¢–æ—á–∫–∞ ${current} –∏–∑ ${total}`;
    document.getElementById("progressFill").style.width = percent + "%";
    document.getElementById("prevBtn").disabled = step === 0;
    document.getElementById("nextBtn").disabled = step === originalTourPath.length - 1;
}

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const hotspots = [];

function createHotspots() {
    hotspots.forEach(h => scene.remove(h));
    hotspots.length = 0;

    const locationHotspots = activeHotspots[panoId] || [];
    const textureLoader = new THREE.TextureLoader();

    locationHotspots.forEach(h => {
        if (mode === "tour" && !freeMode && h.type === "scene") return;

        const icon = h.type === "scene" ? "images/arrow.png" : "images/hotspot.png";
        const sprite = new THREE.Sprite(
            new THREE.SpriteMaterial({
                map: textureLoader.load(icon),
                depthTest: false,
                transparent: true
            })
        );

        sprite.scale.set(h.type === "scene" ? 40 : 30, h.type === "scene" ? 40 : 30, 1);

        const phi = THREE.MathUtils.degToRad(90 - h.pitch);
        const theta = THREE.MathUtils.degToRad(h.yaw);

        sprite.position.set(
            450 * Math.sin(phi) * Math.cos(theta),
            450 * Math.cos(phi),
            450 * Math.sin(phi) * Math.sin(theta)
        );

        sprite.userData = h;
        scene.add(sprite);
        hotspots.push(sprite);
    });
}

function checkHotspot(x, y) {
    mouse.x = (x / innerWidth) * 2 - 1;
    mouse.y = -(y / innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const hit = raycaster.intersectObjects(hotspots)[0];
    if (!hit) return;

    const d = hit.object.userData;

    if (d.type === "info") {
        showInfo(d);
    }
    
    if (d.type === "scene" && (mode === "map" || freeMode)) {
        location.href = `pano.html?${mode === "tour" ? `mode=tour&start=${originalTourPath[0]}&end=${originalTourPath[originalTourPath.length-1]}&step=${step}&` : ''}id=${d.targetId}`;
    }
}

let dragging = false, sx = 0, sy = 0;

addEventListener("mousedown", e => {
    dragging = true; sx = e.clientX; sy = e.clientY;
});

addEventListener("mousemove", e => {
    if (!dragging) return;
    lon += (sx - e.clientX) * 0.1;
    lat += (e.clientY - sy) * 0.1;
    sx = e.clientX; sy = e.clientY;
});

addEventListener("touchstart", e => {
    sx = e.touches[0].clientX;
    sy = e.touches[0].clientY;
});

addEventListener("touchmove", e => {
    lon += (sx - e.touches[0].clientX) * 0.1;
    lat += (e.touches[0].clientY - sy) * 0.1;
    sx = e.touches[0].clientX;
    sy = e.touches[0].clientY;
});

addEventListener("mouseup", e => {
    dragging = false;
    checkHotspot(e.clientX, e.clientY);
});

addEventListener("touchend", () => {
    checkHotspot(sx, sy);
});

addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

function animate() {
    requestAnimationFrame(animate);

    lat = Math.max(-85, Math.min(85, lat));
    const phi = THREE.MathUtils.degToRad(90 - lat);
    const theta = THREE.MathUtils.degToRad(lon);

    camera.lookAt(
        500 * Math.sin(phi) * Math.cos(theta),
        500 * Math.cos(phi),
        500 * Math.sin(phi) * Math.sin(theta)
    );

    renderer.render(scene, camera);
}

(async () => {
    await loadStoredData();

    const params = new URLSearchParams(location.search);
    mode = params.get("mode") ?? "map";
    step = Number(params.get("step") ?? 0);
    panoId = Number(params.get("id"));

    if (mode === "tour") {
        const start = params.get("start");
        const end = params.get("end");
        tourPath = routes[`${start}-${end}`] || [];
        originalTourPath = [...tourPath];
        panoId = tourPath[step];
        
        document.getElementById("tourNav").style.display = "flex";
        document.getElementById("freeModeBtn").style.display = "block";
        document.getElementById("progressBar").style.display = "block";
        updateProgress();
    }

    const loc = activeLocations.find(l => l.id === panoId);

    if (!loc) {
        document.body.innerHTML = `
            <div style="color:white; padding:40px; text-align:center; font-family:sans-serif;">
                <h1>‚ö†Ô∏è –õ–æ–∫–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</h1>
                <p>–õ–æ–∫–∞—Ü–∏—è —Å ID ${panoId} –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç</p>
                <button onclick="location.href='index.html'" style="padding:10px 20px; font-size:16px; cursor:pointer; margin-top:20px;">
                    üó∫Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –∫–∞—Ä—Ç—É
                </button>
            </div>
        `;
        return;
    }

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(loc.startFov || 75, innerWidth / innerHeight, 1, 1100);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.SphereGeometry(500, 60, 40);
    geometry.scale(-1, 1, 1);

    let imageSrc = loc.panorama;

    if (loc.panorama.startsWith('pano_')) {
        try {
            const base64 = await loadImage(loc.panorama);
            if (base64) imageSrc = base64;
        } catch (e) {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ IndexedDB');
        }
    }

    const texture = new THREE.TextureLoader().load(
        imageSrc,
        () => {
            document.getElementById('loading').style.display = 'none';
        },
        undefined,
        (err) => {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã:', err);
            document.getElementById('loading').textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏';
        }
    );

    const sphere = new THREE.Mesh(
        geometry,
        new THREE.MeshBasicMaterial({ map: texture })
    );
    scene.add(sphere);

    lon = loc.startYaw || 0;
    lat = loc.startPitch || 0;

    createHotspots();
    animate();
})();
</script>
</body>
</html>